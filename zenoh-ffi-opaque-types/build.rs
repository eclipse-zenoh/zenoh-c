use std::
    collections::HashMap
;

mod buildrs;

// This script copies it's own project (with necessary modifications,
// e.g. without the build.rs itself) to the root of target directory
// (on the same level as debug and release directories)
// and builds it with separate cargo session unrelated to the current one.
//
// The expected result of this execution is a bunch of error messages
// carrying information about alignment and sizes of strucutes in question.
//
// More detailed logic:
//
//  Project structure:
//
//  The `zenoh-ffi-opaque-types` sources plays double role. As a dependency for
//  the `zenoh-ffi` library it provides repr-C types for corresponding
//  Rust types. These types are auto generated by the build.rs and included
//  in the `lib.rs` of the `zenoh-ffi-opaque-types` crate.
//
//  The purpose of source file `src/probe.rs` is to calculate
//  the size and alignment of the opaque types. To do this it is compiled
//  by "cargo build" in the separate directory by the build.rs.
//  I.e. in the `zenoh-ffi-opaque-types` project itself the file `src/probe.rs`
//  plays only dummy role and included to it for simplifying development.
//
//  Build.rs algorithm
//
//  I. probe project preparation
//
//  To avoid unncessary rebuilds, in the steps below do not update destination
//  files if their contents would not change as a result of the operation.
//
//  1. create directories `opaque-types/probe` in the target directory
//     (4-level up from OUT_DIR)
//  2. create file Cargo.toml in the `opaque-types` directory which
//     will serve as local workspace
//  3. copy project's Cargo.toml to the `probe` directory
//  4. copy src/probe.rs to the `probe` directory with the name lib.rs
//  5. copy Cargo.lock file to `opaque-types` directory. Use
//     prebindgen_project_root::get_project_root() to find the project root,
//     allow also to pass CARGO_LOCK variable to get the path to Cargo.lock
//
//  II. cargo build execution
//
//  Cargo build for `probe` can be executed once or twice, depending if the cross-compilation
//  is required. When zenoh-ffi-opaque-types is built as a dependency for
//  build.rs of the destination project, it's TARGET is a host platform. But
//  the destination project itself may be being built for a different target.
//  To provide the information about this target the variable CROSS_TARGET
//  must be set manually. E.g.
//  CROSS_TARGET=x86_64-unknown-linux-gnu cargo build --target x86_64-unknown-linux-gnu
//  It's also possible that the linker is different for the target platform.
//  The variable CROSS_RUSTC_LINKER must be set manually also in this case.
//
//  Steps:
//
//  1. get target from TARGET variable
//  2. get linker from RUSTC_LINKER variable if present
//  3. Do the cargo build, store output for TARGET
//  4. if CROSS_TARGET variable is present and different from TARGET
//  4.1 get target from CROSS_TARGET variable
//  4.2 get linker from CROSS_RUSTC_LINKER variable if present
//  4.3 Do the cargo build, store output for CROSS_TARGET
//  5. return the outputs for both targets
//
//  Cargo build steps:
//
//  1. create features cargo argument using `prebindgen::get_enabled_features()`. Enable "panic" feature
//  2. create target cargo argument from target parameter
//  3. create linker cargo argument from linker parameter if present
//  4. run cargo build with the arguments, return output
//
//  III. analysis
//
//  1. For each target cargo output
//  1.1. parse cargo output, parse error messages with size/align reports
//  1.2. panic if cargo error detected.
//  1.3. panic if no rust errors detected
//  1.4. panic if total count of errors differs from count of reports collected
//  1.5. return size/alignment data for the target
//
//  IIII. generation
//
//  For each structure in the size/alignment data write to the output file
//  the elements below. More detailed information is in the existing code itself
//
//  1. declare repr-C structure with alignment attribute
//  2. inside the structure the byte array of size elements
//  3 structure is prepended with #prebindgen macro with cfg= attribute
//       restricting this structure for the specified target
//  4. if the structure not owned, add derive Copy, Clone
//  5. if the structure is owned, add the corresponding "moved" structure
//  6. for the "moved" structure implement TakeCType trait
//  7. for the owned structure implement Drop trait

pub fn main() {
    // Prepare to collect structure definitions for dependent FFI crates
    prebindgen::init_prebindgen_out_dir();

    // Step I: probe project preparation
    println!("cargo:rerun-if-env-changed=CARGO_LOCK");
    println!("cargo:rerun-if-env-changed=CROSS_TARGET");
    println!("cargo:rerun-if-env-changed=OPAQUE_TYPES_BUILD_DIR");
    println!("cargo:rerun-if-changed=src");
    println!("cargo:rerun-if-changed=Cargo.toml");
    println!("cargo:rerun-if-changed=build.rs");

    // Step I
    buildrs::generate_probe_project();

    // Step II: execute cargo build for the probe project and capture outputs into files
    let probe_build_outputs = buildrs::build_probe_project();
    for (target, output_path) in &probe_build_outputs {
        println!(
            "cargo:warning=Generated probe build output for {}: {}",
            target,
            output_path.display()
        );
    }

    // Step III: analyze each probe build output, extract size and alignment data
    let mut layouts = HashMap::new();
    for (target, path) in &probe_build_outputs {
        let parsed = buildrs::parse_probe_result(path);
        println!(
            "cargo:warning=Parsed for target {}: {} type layout records",
            target,
            parsed.len()
        );
        layouts.insert(target.as_str(), parsed);
    }

    // Step IV: generate rust code into OUT_DIR/opaque_types.rs
    let generated = buildrs::generate_rust_types(&layouts);
    println!(
        "cargo:warning=Generated opaque types file: {}",
        generated.display()
    );
}